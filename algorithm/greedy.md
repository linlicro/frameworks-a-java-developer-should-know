# 贪婪算法

* 学习如何处理不可能完成的任务
* 学习识别NP完全问题
* 学习近似算法
* 学习贪婪策略

## 教室调度问题

假设有以下课程表，希望尽可能多的课程安排在某间教室。

课程 | 开始时间 | 结束时间
--- | --- | ---
美术 | 9 AM | 10 AM
英语 | 9:30 AM | 10:30 AM
数学 | 10 AM | 11 AM
计算机 | 10:30 AM | 11:30 AM
音乐 | 11 AM | 12 AM

解决方案:

* 选出最早结束的课
* 选出 在上述课结束后，才开始且最早结束的课 -- 重复

## 集合覆盖问题

假设你办个广播节目，要让50个州的听众听到，你需要决定在哪些广播台播出，且需要尽可能少，以减少支出费用。

一般的做法:

* 列出每个可能的广播集合，可能有2^n个
* 在上述集合中选出最小的集合

因集合有2^n个，运行时间为O(2^n)。如果广播台很多，运行时间将激增，导致无法足够快地解决这个问题。

### 近似算法

使用贪婪算法可以得到非常近似的答案。

* 选出「覆盖了最多的未覆盖州」的广播台
* 重复第一步，直至覆盖了所有

运行时间为 O(n^2)。

代码实现: [greedy01.py](greedy01.py)

## NP 完全问题

回头看看 旅行商问题: ...

NP完全问题的简单定义是，以难解著称的问题。

### 如何识别NP完全问题

要判断问题是不是NP完全问题很难，但还是有一些蛛丝马迹可循:

* 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢
* 涉及 "所有组合" 的问题通常是NP完全问题
* 不能将问题分成小问题，必须考虑各种可能的情况，这可能是NP完全问题
* 如何问题涉及序列(如旅行商问题中的城市序列)且难以解决，它可能是NP完全问题
* 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题

## 小结

* 贪婪算法寻找最优解，企图以这种方式获得全局最优解
* 对于NP完全问题，还没有找到快速解决方案
* 面临NP完全问题时，最佳的做法是使用近似算法
* 贪婪算法易于实现、运行速度快，是不错的近似算法

## leetcode

* [best-time-to-buy-and-sell-stock-ii](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
* [more](https://leetcode-cn.com/tag/greedy/)
